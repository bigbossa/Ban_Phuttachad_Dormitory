import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/providers/AuthProvider";
import { useLanguage } from "@/providers/LanguageProvider";
import type { Database } from "@/integrations/supabase/types";
import { Action } from "@radix-ui/react-toast";

type Tenant = Database["public"]["Tables"]["tenants"]["Row"] & {
  current_room?: {
    id: string;
    room_number: string;
    room_type: string;
    floor: number;
  } | null;
  check_out_date?: string | null;
};
type TenantInsert = Database["public"]["Tables"]["tenants"]["Insert"] & {
  id?: string;
  first_name: string;
  last_name: string;
  email: string;
  phone: string;
  address: string;
  created_at?: string;
};
type TenantUpdate = Database["public"]["Tables"]["tenants"]["Update"];

type RoomUpdate = Database["public"]["Tables"]["rooms"]["Update"] & {
  tenant_id?: string;
};

export const useTenants = () => {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const { user, session } = useAuth();
  const { t } = useLanguage();

  const {
    data: tenants = [],
    isLoading,
    error,
  } = useQuery({
    queryKey: ["tenants"],
    queryFn: async () => {
      console.log("Fetching tenants...");

      // First get all tenants
      const { data: tenantsData, error: tenantsError } = await supabase
        .from("tenants")
        .select("*");

      if (tenantsError) {
        console.error("Error fetching tenants:", tenantsError);
        throw tenantsError;
      }

      console.log("Tenants fetched:", tenantsData);

      // Then get current occupancy with room details for each tenant
      const tenantsWithRooms = await Promise.all(
        (tenantsData || []).map(async (tenant) => {
          // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• occupancy ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á tenant ‡∏ô‡∏µ‡πâ
          const { data: allOccupancyData } = await supabase
            .from("occupancy")
            .select(
              `
              room_id,
              check_out_date,
              is_current,
              rooms!occupancy_room_id_fkey(
                id,
                room_number,
                room_type,
                floor
              )
            `
            )
            .eq("tenant_id", tenant.id)
            .order("created_at", { ascending: false });

          // ‡∏´‡∏≤‡∏´‡πâ‡∏≠‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (is_current: true) ‡∏´‡∏£‡∏∑‡∏≠‡∏´‡πâ‡∏≠‡∏á‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
          const currentOccupancy = allOccupancyData?.find(
            (occ) => occ.is_current
          );
          const current_room = currentOccupancy?.rooms
            ? {
                id: currentOccupancy.rooms.id,
                room_number: currentOccupancy.rooms.room_number,
                room_type: currentOccupancy.rooms.room_type,
                floor: currentOccupancy.rooms.floor,
              }
            : null;

          // ‡∏´‡∏≤ check_out_date ‡∏à‡∏≤‡∏Å occupancy ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (is_current: false)
          let check_out_date = null;
          const checkOutOccupancy = allOccupancyData?.find(
            (occ) => !occ.is_current && occ.check_out_date
          );
          if (checkOutOccupancy) {
            check_out_date = checkOutOccupancy.check_out_date;
          }

          return {
            ...tenant,
            current_room,
            check_out_date,
          };
        })
      );

      console.log("Tenants with room info:", tenantsWithRooms);

      // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏≤‡∏° check_out_date (‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡πà‡∏≠‡∏ô) ‡πÅ‡∏•‡∏∞ created_at (‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡πà‡∏≠‡∏ô)
      const sortedTenants = tenantsWithRooms.sort((a, b) => {
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ check_out_date ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏π‡πà ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° check_out_date
        if (a.check_out_date && b.check_out_date) {
          return (
            new Date(b.check_out_date).getTime() -
            new Date(a.check_out_date).getTime()
          );
        }
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÅ‡∏Ñ‡πà a ‡∏°‡∏µ check_out_date ‡πÉ‡∏´‡πâ a ‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡πà‡∏≠‡∏ô
        if (a.check_out_date && !b.check_out_date) {
          return -1;
        }
        // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÅ‡∏Ñ‡πà b ‡∏°‡∏µ check_out_date ‡πÉ‡∏´‡πâ b ‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡πà‡∏≠‡∏ô
        if (!a.check_out_date && b.check_out_date) {
          return 1;
        }
        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ check_out_date ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏π‡πà ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° created_at
        return (
          new Date(b.created_at!).getTime() - new Date(a.created_at!).getTime()
        );
      });

      return sortedTenants;
    },
    enabled: !!user,
  });

  const createTenantMutation = useMutation({
    mutationFn: async (newTenant: TenantInsert) => {
      // 1. Insert ‡∏•‡∏á tenants ‡∏Å‡πà‡∏≠‡∏ô
      const { data: tenantData, error: tenantError } = await supabase
        .from("tenants")
        .insert({
          first_name: newTenant.first_name,
          last_name: newTenant.last_name,
          email: newTenant.email,
          phone: newTenant.phone,
          address: newTenant.address,
          emergency_contact: newTenant.emergency_contact || "",
          room_id: newTenant.room_id || "",
          room_number: newTenant.room_number || "",
          residents: newTenant.residents || "",
        })
        .select()
        .single();

      if (tenantError) throw tenantError;

      // 2. ‡∏´‡∏≤ room_id ‡πÅ‡∏•‡∏∞ capacity ‡∏à‡∏≤‡∏Å room_number
      const { data: roomData, error: roomError } = await supabase
        .from("rooms")
        .select("id, capacity")
        .eq("room_number", tenantData.room_number)
        .single();

      if (roomError || !roomData) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö");

      const room_id = roomData.id;

      // 3. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡πà‡∏≤ tenant ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ú‡∏π‡∏Å‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      const { count: existingOccupancyCount, error: existingError } =
        await supabase
          .from("occupancy")
          .select("*", { count: "exact", head: true })
          .eq("tenant_id", tenantData.id)
          .eq("room_id", room_id)
          .eq("is_current", true);

      if (existingError) throw existingError;

      if (existingOccupancyCount === 0) {
        // 4. Insert occupancy
        const { error: occupancyError } = await supabase
          .from("occupancy")
          .insert({
            tenant_id: tenantData.id,
            room_id: room_id,
            check_in_date: new Date().toISOString().split("T")[0],
            is_current: true,
          });

        if (occupancyError) throw occupancyError;
      }

      // 5. ‡∏î‡∏∂‡∏á count ‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ
      const { count: currentOccupantCount, error: countError } = await supabase
        .from("occupancy")
        .select("*", { count: "exact", head: true })
        .eq("room_id", room_id)
        .eq("is_current", true);

      if (countError) throw countError;

      // üëâ Debug log
      const effectiveCapacity = Math.max(roomData.capacity ?? 2, 2);
      console.log(
        `‡∏´‡πâ‡∏≠‡∏á ${newTenant.room_number} ‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏Å‡∏≠‡∏≤‡∏®‡∏±‡∏¢ ${currentOccupantCount}/${effectiveCapacity}`
      );

      // 6. ‡∏ñ‡πâ‡∏≤‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏ñ‡∏∂‡∏á capacity ‡∏Ñ‡πà‡∏≠‡∏¢‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á
      if (currentOccupantCount >= effectiveCapacity) {
        const { error: statusError } = await supabase
          .from("rooms")
          .update({ status: "occupied" })
          .eq("id", room_id);
        if (statusError) throw statusError;
      } else {
        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ï‡πá‡∏° ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô vacant ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡∏ú‡∏¥‡∏î
        await supabase
          .from("rooms")
          .update({ status: "vacant" })
          .eq("id", room_id);
      }

      return tenantData;
    },

    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["tenants"] });
      queryClient.invalidateQueries({
        queryKey: ["available-rooms-with-capacity"],
      });
      queryClient.invalidateQueries({ queryKey: ["system-stats"] });
      toast({
        title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        description: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
      });
    },

    onError: (error) => {
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ",
        variant: "destructive",
      });
    },
  });

  const updateTenantMutation = useMutation({
    mutationFn: async ({
      id,
      updates,
    }: {
      id: string;
      updates: TenantUpdate;
    }) => {
      console.log("Updating tenant:", id, updates);
      const { data, error } = await supabase
        .from("tenants")
        .update(updates)
        .eq("id", id)
        .select()
        .single();

      if (error) {
        console.error("Error updating tenant:", error);
        throw error;
      }

      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["tenants"] });
      toast({
        title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        description: "‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
      });
    },
    onError: (error) => {
      console.error("Update tenant error:", error);
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ",
        variant: "destructive",
      });
    },
  });

  const deleteTenantMutation = useMutation({
    mutationFn: async (tenantId: string) => {
      console.log("tenantId ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö:", tenantId);

      // 1. ‡∏î‡∏∂‡∏á tenant ‡∏´‡∏•‡∏±‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ room_id ‡πÅ‡∏•‡∏∞ room_number
      const { data: tenant, error: tenantFetchError } = await supabase
        .from("tenants")
        .select("id, room_id, room_number")
        .eq("id", tenantId)
        .maybeSingle();

      if (tenantFetchError || !tenant) {
        throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤");
      }

      const { room_id: roomId, room_number: roomNumber } = tenant;

      if (!roomId) {
        throw new Error("‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ room_id");
      }

      // 2. ‡∏î‡∏∂‡∏á tenant ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô room ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
      const { data: tenantsInRoom, error: tenantsError } = await supabase
        .from("tenants")
        .select("id")
        .eq("room_id", roomId);

      if (tenantsError || !tenantsInRoom) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ");
      }

      const tenantIds = tenantsInRoom.map((t) => t.id);

      // 3. ‡∏î‡∏∂‡∏á profiles ‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö tenant ‡∏û‡∏ß‡∏Å‡∏ô‡∏µ‡πâ
      const { data: profiles, error: profilesError } = await supabase
        .from("profiles")
        .select("id, tenant_id")
        .in("tenant_id", tenantIds);

      if (profilesError) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á profiles ‡πÑ‡∏î‡πâ");
      }

      const userIds = profiles.map((p) => p.id);

      // 4. ‡∏•‡∏ö tenant_id, staff_id ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å profiles
      if (userIds.length > 0) {
        const { error: updateProfileError } = await supabase
          .from("profiles")
          .update({ tenant_id: null, staff_id: null })
          .in("id", userIds);

        if (updateProfileError) {
          throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡πâ‡∏≤‡∏á tenant_id ‡πÉ‡∏ô profiles ‡πÑ‡∏î‡πâ");
        }
      }

      // 5. ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ï‡πå‡∏à‡∏≤‡∏Å occupancy
      const { error: checkoutError } = await supabase
        .from("occupancy")
        .update({
          is_current: false,
          check_out_date: new Date().toISOString().split("T")[0],
        })
        .in("tenant_id", tenantIds)
        .eq("is_current", true);

      if (checkoutError) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï check-out occupancy ‡πÑ‡∏î‡πâ");
      }

      // 6. ‡∏•‡∏ö room_id / room_number ‡∏à‡∏≤‡∏Å tenants
      // const { error: clearTenantRoomError } = await supabase
      //   .from("tenants")
      //   .update({ room_id: "", room_number: "" })
      //   .in("id", tenantIds);

      // if (clearTenantRoomError) {
      //   throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå‡∏´‡πâ‡∏≠‡∏á‡∏à‡∏≤‡∏Å tenants ‡πÑ‡∏î‡πâ");
      // }

      // 7. ‡∏•‡∏ö tenants
      const { error: deleteTenantError } = await supabase
        .from("tenants")
        .update({ action: 2 })
        .in("id", tenantIds);

      if (deleteTenantError) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ");
      }

      // 8. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô vacant
      const { error: updateRoomStatusError } = await supabase
        .from("rooms")
        .update({ status: "vacant" })
        .eq("id", roomId);

      if (updateRoomStatusError) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡πà‡∏≤‡∏á‡πÑ‡∏î‡πâ");
      }
      // 9. ‡∏•‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å Supabase Auth
      //   if (userIds.length > 0) {
      //     const resp = await fetch(
      //       "https://mnsotnlftoumjwjlvzus.functions.supabase.co/manage-auth-users",
      //       {
      //         method: "DELETE",
      //         headers: {
      //           "Content-Type": "application/json",
      //           Authorization: `Bearer ${session?.access_token}`,
      //           apikey: "YOUR_API_KEY", // ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å env ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô production
      //         },
      //         body: JSON.stringify({ user_ids: userIds }),
      //       }
      //     );

      //     if (!resp.ok) {
      //       const data = await resp.json();
      //       throw new Error(data.error || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ");
      //     }
      //   }
      // },

      // onSuccess: () => {
      //   queryClient.invalidateQueries({ queryKey: ["tenants"] });
      //   queryClient.invalidateQueries({ queryKey: ["rooms"] });
      //   toast({
      //     title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      //     description: "‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
      //   });
      // },

      // onError: (error: any) => {
      //   console.error("Delete tenant error:", error);
      //   toast({
      //     title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
      //     description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
      //     variant: "destructive",
      //   });
      return "‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß";
    },

    onSuccess: (message) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï query cache ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ React Query)
      queryClient.invalidateQueries({ queryKey: ["tenants"] });
      queryClient.invalidateQueries({ queryKey: ["rooms"] });

      // ‡πÅ‡∏™‡∏î‡∏á toast ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
      toast({
        title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        description: message || "‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
      });
    },

    onError: (error: any) => {
      console.error("Delete tenant error:", error);
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
        variant: "destructive",
      });
    },
  });

  const deleteRentedchildMutation = useMutation({
    mutationFn: async (tenantId: string) => {
      console.log("tenantId ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö:", tenantId);

      // 1. ‡∏î‡∏∂‡∏á tenant ‡∏´‡∏•‡∏±‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤ room_id
      const { data: tenant, error: tenantFetchError } = await supabase
        .from("tenants")
        .select("id, room_id, room_number, residents")
        .eq("id", tenantId)
        .maybeSingle();

      if (tenantFetchError || !tenant) {
        throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤");
      }

      const { room_id: roomId } = tenant;

      if (!roomId) {
        throw new Error("‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ room_id");
      }

      // 2. ‡∏î‡∏∂‡∏á tenants ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô (‡∏û‡∏£‡πâ‡∏≠‡∏° residents)
      const { data: tenantsInRoom, error: tenantsError } = await supabase
        .from("tenants")
        .select("id, residents")
        .eq("room_id", roomId);

      if (tenantsError || !tenantsInRoom) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ");
      }

      // 3. ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ tenant ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤ (‡∏°‡∏µ residents ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà tenant ‡∏´‡∏•‡∏±‡∏Å)
      const rentedChildTenants = tenantsInRoom.filter(
        (t) => t.residents !== null && t.id !== tenantId
      );

      const tenantIdsToDelete = rentedChildTenants.map((t) => t.id);

      if (tenantIdsToDelete.length === 0) {
        throw new Error("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏•‡∏ö‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ");
      }

      // 4. ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏≠‡∏≤‡∏ï‡πå‡∏à‡∏≤‡∏Å occupancy
      const { error: checkoutError } = await supabase
        .from("occupancy")
        .update({
          is_current: false,
          check_out_date: new Date().toISOString().split("T")[0],
        })
        .in("tenant_id", tenantIdsToDelete)
        .eq("is_current", true);

      if (checkoutError) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï check-out occupancy ‡πÑ‡∏î‡πâ");
      }

      // 5. ‡∏•‡∏ö tenants
      const { error: deleteTenantError } = await supabase
        .from("tenants")
        .update({ action: 2 })
        .in("id", tenantIdsToDelete);

      if (deleteTenantError) {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡πà‡∏≤‡πÑ‡∏î‡πâ");
      }
    },

    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["tenants"] });
      queryClient.invalidateQueries({ queryKey: ["rooms"] });
      window.location.reload();
      toast({
        title: "‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        description: "‡∏•‡∏ö‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
      });
    },

    onError: (error: any) => {
      console.error("Delete tenant error:", error);
      toast({
        title: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î",
        description: error.message || "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ",
        variant: "destructive",
      });
    },
  });

  const assignRoomMutation = useMutation({
    mutationFn: async ({
      tenantId,
      roomId,
    }: {
      tenantId: string;
      roomId: string;
    }) => {
      console.log("Assigning room:", { tenantId, roomId });

      // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏•‡∏∞ capacity)
      const { data: roomData, error: roomError } = await supabase
        .from("rooms")
        .select("id, capacity, room_number, status")
        .eq("id", roomId)
        .single();
      if (roomError) throw roomError;
      if (roomData.status === "maintenance") {
        throw new Error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ã‡πà‡∏≠‡∏°‡πÅ‡∏ã‡∏°‡πÑ‡∏î‡πâ");
      }

      // ‡∏ô‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏Å‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
      const { data: currentOccupancy, error: occupancyError } = await supabase
        .from("occupancy")
        .select("tenant_id")
        .eq("room_id", roomId)
        .eq("is_current", true);
      if (occupancyError) throw occupancyError;
      const currentOccupants = currentOccupancy?.length || 0;
      if (currentOccupants !== 0) {
        throw new Error("‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏Å‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô");
      }

      // ‡∏´‡∏≤ room_id ‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á tenant ‡∏ô‡∏µ‡πâ
      const { data: oldOcc, error: oldOccErr } = await supabase
        .from("occupancy")
        .select("room_id")
        .eq("tenant_id", tenantId)
        .eq("is_current", true)
        .maybeSingle();
      if (oldOccErr) throw oldOccErr;
      const oldRoomId = oldOcc?.room_id || null;

      // ‡∏õ‡∏¥‡∏î occupancy ‡∏Ç‡∏≠‡∏á tenant ‡∏´‡∏•‡∏±‡∏Å
      await supabase
        .from("occupancy")
        .update({
          is_current: false,
          check_out_date: new Date().toISOString().split("T")[0],
        })
        .eq("tenant_id", tenantId)
        .eq("is_current", true);

      // ‡πÄ‡∏õ‡∏¥‡∏î occupancy ‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ tenant ‡∏´‡∏•‡∏±‡∏Å
      const { data, error } = await supabase
        .from("occupancy")
        .insert({
          tenant_id: tenantId,
          room_id: roomId,
          check_in_date: new Date().toISOString().split("T")[0],
          is_current: true,
        })
        .select()
        .single();
      if (error) throw error;

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï tenant ‡∏´‡∏•‡∏±‡∏Å ‡∏î‡πâ‡∏ß‡∏¢‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
      const { error: updateTenantError } = await supabase
        .from("tenants")
        .update({ room_number: roomData.room_number, room_id: roomId })
        .eq("id", tenantId);
      if (updateTenantError) throw updateTenantError;

      // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°: ‡∏¢‡πâ‡∏≤‡∏¢‡∏•‡∏π‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ï‡∏≤‡∏°‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢
      if (oldRoomId) {
        // ‡∏´‡∏≤ tenant ‡∏•‡∏π‡∏Å‡∏´‡πâ‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°
        const { data: childTenants, error: childErr } = await supabase
          .from("tenants")
          .select("id")
          .eq("room_id", oldRoomId)
          .eq("residents", "‡∏•‡∏π‡∏Å‡πÄ‡∏ä‡πà‡∏≤");
        if (childErr) throw childErr;

        // ‡∏õ‡∏¥‡∏î occupancy ‡πÄ‡∏Å‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏´‡πâ‡∏≠‡∏á ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
        if (childTenants && childTenants.length > 0) {
          const childIds = childTenants.map((t) => t.id);

          await supabase
            .from("occupancy")
            .update({
              is_current: false,
              check_out_date: new Date().toISOString().split("T")[0],
            })
            .in("tenant_id", childIds)
            .eq("is_current", true);

          const newChildOccupancies = childIds.map((cid) => ({
            tenant_id: cid,
            room_id: roomId,
            check_in_date: new Date().toISOString().split("T")[0],
            is_current: true,
          }));
          await supabase.from("occupancy").insert(newChildOccupancies);

          // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï room_id ‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
          await supabase
            .from("tenants")
            .update({ room_id: roomId, room_number: roomData.room_number })
            .in("id", childIds);
        }
      }

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô occupied
      await supabase
        .from("rooms")
        .update({ status: "occupied" })
        .eq("id", roomId);

      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°: ‡∏ï‡∏£‡∏ß‡∏à‡∏ú‡∏π‡πâ‡∏û‡∏±‡∏Å‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ‡∏ñ‡πâ‡∏≤ 0 ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô vacant
      if (oldRoomId) {
        const { data: leftOcc } = await supabase
          .from("occupancy")
          .select("tenant_id")
          .eq("room_id", oldRoomId)
          .eq("is_current", true);
        const leftCount = leftOcc?.length || 0;
        await supabase
          .from("rooms")
          .update({ status: leftCount > 0 ? "occupied" : "vacant" })
          .eq("id", oldRoomId);
      }

      return data;
    },

    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["tenants"] });
      queryClient.invalidateQueries({
        queryKey: ["available-rooms-with-capacity"],
      });
      queryClient.invalidateQueries({ queryKey: ["system-stats"] });
      toast({
        title: t("tenants.success"),
        description: t("tenants.roomAssignedSuccess"),
      });
    },

    onError: (error) => {
      toast({
        title: t("tenants.error"),
        description: error.message || t("tenants.cannotAssignRoom"),
        variant: "destructive",
      });
    },
  });

  return {
    tenants,
    isLoading,
    error,
    createTenant: createTenantMutation.mutate,
    updateTenant: updateTenantMutation.mutate,
    deleteTenant: deleteTenantMutation.mutate,
    deleteRentedchild: deleteRentedchildMutation.mutate,
    assignRoom: (tenantId: string, roomId: string) =>
      assignRoomMutation.mutate({ tenantId, roomId }),
    isCreating: createTenantMutation.isPending,
    isUpdating: updateTenantMutation.isPending,
    isDeleting: deleteTenantMutation.isPending,
    isAssigningRoom: assignRoomMutation.isPending,
  };
};
